var documenterSearchIndex = {"docs":
[{"location":"#ClimaComms","page":"Home","title":"ClimaComms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ClimaComms","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimaComms","category":"page"},{"location":"#ClimaComms.ClimaComms","page":"Home","title":"ClimaComms.ClimaComms","text":"ClimaComms\n\nAbstracts the communications interface for the various CliMA components in order to:\n\nenable the use of different backends as transports (MPI, SharedArrays, etc.), and\ntransparently support single or double buffering for GPUs, depending on whether the transport has the ability to access GPU memory.\n\nUse one of the ClimaComms backends, currently:\n\nClimaCommsMPI uses MPI-2 asynchronous primitives through MPI.jl and supports a single buffer if the MPI implementation is CUDA-aware.\nClimaCommsSA uses Julia's Distributed capability and SharedArrays.jl for within-node communication.\n\n\n\n\n\n","category":"module"},{"location":"#Contexts","page":"Home","title":"Contexts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ClimaComms.AbstractCommsContext","category":"page"},{"location":"#ClimaComms.AbstractCommsContext","page":"Home","title":"ClimaComms.AbstractCommsContext","text":"AbstractCommsContext\n\nThe base type for a communications context. Each backend defines a concrete subtype of this, an instance of which is constructed by passing in an array of Neighbors.\n\n\n\n\n\n","category":"type"},{"location":"#Communication-interface","page":"Home","title":"Communication interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ClimaComms.init\nClimaComms.mypid\nClimaComms.iamroot\nClimaComms.nprocs\nClimaComms.singlebuffered\nClimaComms.start\nClimaComms.progress\nClimaComms.finish\nClimaComms.barrier\nClimaComms.reduce\nClimaComms.abort","category":"page"},{"location":"#ClimaComms.init","page":"Home","title":"ClimaComms.init","text":"init(::Type{CC}) where {CC <: AbstractCommsContext}\n\nPerform any necessary initialization for the specified backend. Return a tuple of the processor ID and the number of participating processors.\n\n\n\n\n\n","category":"function"},{"location":"#ClimaComms.mypid","page":"Home","title":"ClimaComms.mypid","text":"mypid(::Type{CC}) where {CC <: AbstractCommsContext}\n\nReturn the processor ID.\n\n\n\n\n\n","category":"function"},{"location":"#ClimaComms.iamroot","page":"Home","title":"ClimaComms.iamroot","text":"iamroot(::Type{CC}) where {CC <: AbstractCommsContext}\n\nReturn true if the calling processor is the root processor.\n\n\n\n\n\n","category":"function"},{"location":"#ClimaComms.nprocs","page":"Home","title":"ClimaComms.nprocs","text":"nprocs(::Type{CC}) where {CC <: AbstractCommsContext}\n\nReturn the number of participating processors.\n\n\n\n\n\n","category":"function"},{"location":"#ClimaComms.singlebuffered","page":"Home","title":"ClimaComms.singlebuffered","text":"singlebuffered(::Type{CC}) where {CC <: AbstractCommsContext}\n\nReturns true if communication can be single-buffered.\n\n\n\n\n\n","category":"function"},{"location":"#ClimaComms.start","page":"Home","title":"ClimaComms.start","text":"start(ctx::CC; kwargs...) where {CC <: AbstractCommsContext}\n\nInitiate communication. The stage areas of all the send RelayBuffers must be filled before this is called!\n\n\n\n\n\n","category":"function"},{"location":"#ClimaComms.progress","page":"Home","title":"ClimaComms.progress","text":"progress(ctx::CC) where {CC <: AbstractCommsContext}\n\nDrive communication. Call after start() to ensure that communication proceeds asynchronously.\n\n\n\n\n\n","category":"function"},{"location":"#ClimaComms.finish","page":"Home","title":"ClimaComms.finish","text":"finish(ctx::CC; kwargs...) where {CC <: AbstractCommsContext}\n\nComplete the communications step begun by start(). After this returns, data received from all neighbors will be available in the stage areas of each neighbor's receive buffer.\n\n\n\n\n\n","category":"function"},{"location":"#ClimaComms.barrier","page":"Home","title":"ClimaComms.barrier","text":"barrier(ctx::CC) where {CC <: AbstractCommsContext}\n\nPerform a global synchronization across all participating processors.\n\n\n\n\n\n","category":"function"},{"location":"#ClimaComms.reduce","page":"Home","title":"ClimaComms.reduce","text":"reduce(ctx::CC, val, op) where {CC <: AbstractCommsContext}\n\nPerform a reduction across all participating processors, using op as the reduction operator and val as this rank's reduction value. Return the result to the first processor only.\n\n\n\n\n\n","category":"function"},{"location":"#ClimaComms.abort","page":"Home","title":"ClimaComms.abort","text":"abort(ctx::CC, status::Int) where {CC <: AbstractCommsContext}\n\nTerminate the caller and all participating processors with the specified status.\n\n\n\n\n\n","category":"function"},{"location":"#Neighbors","page":"Home","title":"Neighbors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ClimaComms.Neighbor","category":"page"},{"location":"#ClimaComms.Neighbor","page":"Home","title":"ClimaComms.Neighbor","text":"Neighbor\n\nRepresents a communications neighbor. Constructors are defined by the backends and require a unique ID that represents the neighbor, the array type to be used for staging (usually Array on the CPU and CuArray for GPU code), the element type for the array, and the dimensions for the send and receive buffers.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"ClimaComms.id\nClimaComms.send_stage\nClimaComms.recv_stage","category":"page"},{"location":"#ClimaComms.send_stage","page":"Home","title":"ClimaComms.send_stage","text":"send_stage(nbr::Neighbor)\n\nReturn the staging area for data that is to be sent to the specified neighbor.\n\n\n\n\n\n","category":"function"},{"location":"#ClimaComms.recv_stage","page":"Home","title":"ClimaComms.recv_stage","text":"recv_stage(nbr::Neighbor)\n\nReturn the staging area for data that has been received from the specified neighbor.\n\n\n\n\n\n","category":"function"}]
}
